n
s
n
p *sq
n
p *sem
p *(sem->first)
p *((sem->first)->next)
src-prof
n
n
n
n
n
n
n
n
p semaphores[sem].value
n
n
p if (semaphores[sem].process_waiting
p if (semaphores[sem].process_waiting)
p (semaphores[sem].process_waiting)
p semaphores[sem].process_waiting
p semaphores[sem].processes_waiting
n
s
p *sem
src-prof
n
n
n
n
p sem->processes_waiting
p *sem
src-prof
p sem->processes_waiting
n
p sem->processes_waiting
n
n
n
n
n
n
n
n
n
s
s
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
p semaphores[sem].value
b sem.c:118
c
c
src-prof
c
exit
quit
b sem.c:118
c
quit
b pipeWrite
b pipeRead
c
n
n
n
n
n
n
p sem_aux_name
typedef struct pipe_ps {
    char occupied;
    uint64_t pid;
quit
b pipeWrite
c
disable 1
b wrapSprintf
c
c
c
c
n
n
n
n
n
n
n
n
quit
b wrapSprintf
c
c
c
n
c
n
n
n
n
n
n
n
s
n
n
n
n
n
n
n
n
n
n
n
n
n
n
p num
n
n
n
n
n
n
n
n
finish
n
n
n
n
finish
info b
disable 1
b pipeWrite
b pipeRead
n
n
n
n
n
n
n
n
p pipes[idx].buffer
n
n
n
n
n
n
n
n
n
n
n
quit
b pipeRead
c
quit
b assignInAndOut
c
c
n
c
n
n
n
n
s
n
s
n
n
p pipes[i].processes[j].pid
quit
b pipeRead
c
n
n
n
n
n
n
n
n
n
p pipes[idx].buffer
n
n
n
n
p pipes[idx]
n
n
nn
n
quit
b pipeRead
c
n
n
n
n
n
n
n
p pipes[idx]
n
n
n
n
n
n
n
n
n
si
s
c
n
n
n
n
n
n
n
n
n
n
n
n
n
n
n
quit
